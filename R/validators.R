#' Validate Napistu Configuration Object
#'
#' @param napistu_config A napistu configuration object of class `napistu_config`
#' containing all necessary configuration settings for the loading required
#' assets and configuring and/or using an exiting appropriate Python environment.
#' This config can be read from a yaml file using \link{load_napistu_config} or
#' directly specified in R using \link{create_napistu_config}. Contains:
#'   
#' \describe{
#'     \item{python_config}{
#'         A shallow list defining the Python environment.
#'         See \link{validate_python_config}
#'     }
#'     \item{assets_config}{
#'         A shallow list defining the Napistu assets to use.
#'         See \link{validate_assets_config}
#'     }
#'     \item{created_at}{Time stamp}
#' }
#'   
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_napistu_config <- function(napistu_config) {
    checkmate::assert_class(napistu_config, NAPISTU_CONSTANTS$NAPISTU_CONFIG_CLASS)
    return(invisible(TRUE))
}

#' Validate Assets Config
#' 
#' @param assets_config List containing asset configuration settings as part of
#' the `napistu_config`. If this is an empty list, the `test_pathway` bundled
#' with `napistu-r` will be used.
#'   
#' \describe{
#'     \item{assets_dir}{
#          Optional, if provided, assets paths are calculated
#'         relative to this directory.
#'     }
#'     \item{sbml_dfs}{
#'         Path to a pickled `SBML_dfs` object generated by the
#'         Napistu Python package. `SBML_df`s are self-contained relational
#'         representations of a pathway.
#'     }
#'     \item{napistu_graph}{
#'         Path to a pickled `NapistuGraph` object generated by the Napistu
#'         Python package. `NapistuGraph`s are a subclass of `igraph.Graph`.
#'         }
#'     \item{species_identifiers}{
#'         Path to a .tsv containing the systematic identifiers for all
#'         of the molecular species in the `SBML_dfs`.
#'     }
#'     \item{precomputed_distances}{
#'         Optional, path to a .parquet file containing pairwise distances
#'         between molecular species. Defining this can speed up the calculation
#'         of shortest paths and neighborhoods.
#'     }
#' }
#' @param minimal_validation If TRUE then only the structure of `assets_config` will
#' be validated. If FALSE then the definition and existence of required assets
#' will be confirmed.
#'
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_assets_config <- function (assets_config, minimal_validation = FALSE) {
    
    checkmate::assert_list(assets_config)
    purrr::walk(assets_config, checkmate::assert_string)
    checkmate::assert_logical(minimal_validation, len = 1)
    
    if (!minimal_validation) {
        if (length(assets_config) == 0) {
            asset_paths <- get_bundled_asset_paths()
        } else {
            asset_paths <- get_configured_asset_paths(assets_config, verbose = FALSE)
        }
    }
    
    return(invisible(TRUE))
}

#' Validate Python Config
#' 
#' @param python_config List describing the Python environment to use as part of
#'     the `napistu_config`. This can be the system python, a virtual environment
#'     or conda. If `python_config` is an empty list, a miniconda environment and
#'     installation can be established on-the-fly.
#'   
#'     \describe{
#'          \item{virtual_env}{Optional, path to a virtual environment}
#'          \item{conda}{
#'              Optional, path to a conda executable. This can be found with
#'              `reticulate::conda_exe()`. If defined, the `conda_env_name` should
#'              also be defined.
#'          }
#'          \item{conda_env_name}{
#'              Optional, name of the conda environment to use. A suitable environment
#'              can be created using \link{create_conda_environment}.
#'          }
#'          \item{python}{
#'              Optional, path to a Python distribution.
#'          }
#'     }
#'   
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_python_config <- function (python_config) {
    
    checkmate::assert_list(python_config)
    purrr::walk(python_config, checkmate::assert_string)
    
    if (length(python_config) > 0) {
        
        env_types <- NAPISTU_CONSTANTS$PYTHON_ENV_TYPES
        specified_types <- intersect(names(python_config), env_types)
        
        if (length(specified_types) == 0) {
            cli::cli_abort("No valid Python environment specified. Use one of: {.val {env_types}}")
        }
        
        if (length(specified_types) > 1) {
            cli::cli_abort("Multiple Python environment types specified: {.val {specified_types}}")
        }
        
        if (specified_types[1] == "conda" && !("conda_env_name" %in% names(python_config))) {
            cli::cli_abort("{.field conda_env_name} must be defined if conda is being used. A suitable environment can be created with {.field create_conda_environment()}")
            
            conda_env_name <- python_config$conda_env_name
            checkmate::assert_string(conda_env_name)
        }
    }
    
    return(invisible(TRUE))
}

#' Validate Asset Paths
#' 
#' @param asset_paths List containing the paths of to-be-loaded assets
#'   
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_asset_paths <- function (asset_paths) {
    
    checkmate::assert_list(asset_paths)
    purrr::walk(asset_paths, checkmate::assert_string)
    purrr::walk(asset_paths, checkmate::test_file_exists)
    return(invisible(TRUE))
}

#' Validate Verbose Parameter
#'
#' @param verbose Logical scalar; if TRUE (default), prints informative messages
#'   about the current operation progress. If FALSE, runs silently.
#'
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_verbose <- function(verbose) {
    checkmate::assert_logical(verbose, len = 1)
    return(invisible(TRUE))
}

#' Validate Verbose Parameter
#'
#' @param overwrite Overwrite existing caches 
#'
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_overwrite <- function(overwrite) {
    checkmate::assert_logical(overwrite, len = 1)
    return(invisible(TRUE))
}

#' Validate Napistu List
#' 
#' Verify that a Napistu List contains the expected Napistu assets
#' 
#' @param napistu_list A list containing loaded assets and bindings to
#'   Python modules.
#'
#' \describe{
#'     \item{sbml_dfs}{
#'         SBML_dfs - the core pathway representation of the Napistu Python library
#'         }
#'     \item{napistu_graph}{
#'         Network graph - a Python igraph subclass with Napistu-specific
#'         attributes and methods
#'         }
#'     \item{species_identifiers}{Species identifier mappings}
#'     \item{precomputed_distances}{optional, distances between species nodes}
#'     \item{species_names}{
#'          A tibble containing the names of all genes, proteins, molecules, etc
#'          }
#'     \item{identifiers_nest}{
#'          A tibble with one row per ontology and a nested tibble containing
#'          all the identifiers and their corresponding molecular species
#'          }
#'     \item{python_modules}{A named list of Python modules: `napistu`}
#'     \item{python_environment}{See \link{validate_python_environment}}
#'     \item{napistu_config}{
#'         A `napistu_config` object dictating how the `napistu_list` was initialized
#'     }
#'     \item{loaded_at}{A date-time object indicating when `napistu_list` was initialized}
#'   }
#'
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_napistu_list <- function (napistu_list) {
    
    checkmate::assert_class(napistu_list, NAPISTU_CONSTANTS$NAPISTU_LIST_CLASS)
    
    # validate napistu_list-level assets
    
    ensure_required_keys(names(napistu_list), NAPISTU_CONSTANTS$NAPISTU_LIST_LEVEL_VARS, "napistu_list")
    checkmate::assert_class(napistu_list$napistu_config, NAPISTU_CONSTANTS$NAPISTU_CONFIG_CLASS)
    checkmate::assert_class(napistu_list$loaded_at, "POSIXct")
    
    # validate asset and python lists which are merged in the napistu_list
    
    validate_asset_list(napistu_list)
    validate_python_list(napistu_list)
    
    return(invisible(TRUE))
}

#' Validate Assets List
#' 
#' @param asset_list A list containing loaded assets including:
#' \describe{
#'     \item{sbml_dfs}{
#'         SBML_dfs - the core pathway representation of the Napistu Python library
#'         }
#'     \item{napistu_graph}{
#'         Network graph - a Python igraph subclass with Napistu-specific
#'         attributes and methods
#'         }
#'     \item{species_identifiers}{Species identifier mappings}
#'     \item{precomputed_distances}{optional, distances between species nodes}
#'     \item{species_names}{
#'          A tibble containing the names of all genes, proteins, molecules, etc
#'          }
#'     \item{identifiers_nest}{
#'          A tibble with one row per ontology and a nested tibble containing
#'          all the identifiers and their corresponding molecular species
#'          }
#'   }
#'   
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_asset_list <- function (asset_list) {
    
    REQUIRED_KEYS <- c(NAPISTU_CONSTANTS$REQUIRED_ASSETS, NAPISTU_CONSTANTS$REQUIRED_DERIVED_ASSETS)
    ensure_required_keys(names(asset_list), REQUIRED_KEYS, "asset_list")
    
    # required attributes
    checkmate::assert_class(asset_list$sbml_dfs, "napistu.sbml_dfs_core.SBML_dfs")
    checkmate::assert_class(asset_list$napistu_graph, "igraph.Graph")
    checkmate::assert_data_frame(asset_list$species_identifiers)
    
    # optional attributes
    if (!is.null(asset_list$precomputed_distances)) {
        checkmate::assert_data_frame(asset_list$precomputed_distances)
    }
    
    # required derived attributes
    
    checkmate::assert_data_frame(asset_list$species_names)
    checkmate::assert_data_frame(asset_list$identifiers_nest)
    
    return(invisible(TRUE))
}

#' Validate Python List
#'
#' @param python_list A list containing reticulate bindings to Python packages and summaries of the Python environment.
#' \describe{
#'     \item{python_modules}{A named list of Python modules: `napistu`}
#'     \item{python_environment}{See \link{validate_python_environment}}
#' }
#' 
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_python_list <- function (python_list) {
    
    checkmate::assertList(python_list)
    ensure_required_keys(names(python_list), NAPISTU_CONSTANTS$PYTHON_CONFIG_VARS, "python_list")
    
    # validate modules
    python_modules <- names(python_list$python_modules)
    missing_modules <- setdiff(
        names(NAPISTU_CONSTANTS$REQUIRED_PYTHON_MODULES),
        python_modules
    )
    if (length(missing_modules) > 0) {
        cli::cli_abort("The {.arg  python_list$python_modules} is missing reticulate bindings to the following package{?s}: {.field {missing_modules}}")
    }
    purrr::walk(python_modules, "python.builtin.module")
    
    # validate environment spec
    validate_python_environment(python_list$python_environment)
    
    return(invisible(TRUE))
}

#' Validate Python Environment
#' 
#' @param python_environment Summary of the loaded Python environment and specification for cleanup procedure used by \link{cleanup_napistu}
#' \describe{
#'     \item{path}{The environment being used}
#'     \item{type}{The type of reticulate configuration: "virtualenv", "conda", "python"}
#'     \item{created_by_napistu}{Was the environment created by Napistu? If so it can be removed by \link{cleanup_napistu}}
#'     \item{miniconda_installed}{Was Miniconda installed by Napistu? If so it can be removed by \link{cleanup_napistu}}
#' }
#' 
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_python_environment <- function (python_environment) {
    
    checkmate::assertList(python_environment)
    ensure_required_keys(names(python_environment), NAPISTU_CONSTANTS$PYTHON_ENV_VARS, "python_environment")
    
    checkmate::assert_string(python_environment$path)
    checkmate::assert_string(python_environment$type)
    checkmate::assert_logical(python_environment$created_by_napistu, len = 1)
    checkmate::assert_logical(python_environment$miniconda_installed, len = 1)
    
    return(invisible(TRUE))
}

#' Validate Neighborhood Table
#' 
#' Determine whether the neighborhood table follows the expected structure.
#' Neighborhoods are a subnetwork of molecular species and reactions tightly connected to
#' a focal vertex.
#' 
#' @param neighborhood_table a tibble produced by \link{create_neighborhood_table}
#' containing one row per neighborhood with nested lists as attributes:
#' \describe{
#'     \item{sc_name}{A human readible name for the focal vertex}
#'     \item{s_id}{The internal unique species id of the focal vertex}
#'     \item{c_id}{The internal unique compartment id of the focal vertex}
#'     \item{sc_id}{The internal unique compartmentalized species id of the focal vertex}
#'     \item{sc_Source}{The Source object for the focal vertex}
#'     \item{vertices}{The vertices in the focal vertex's neighborhood}
#'     \item{edges}{The edges in the focal vertex's neighborhood}
#'     \item{reaction_sources}{The source pathways of the reaction vertices}
#' }
#' 
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_neighborhood_table <- function (neighborhood_table) {
    
    checkmate::assert_character(neighborhood_table$sc_name)
    checkmate::assert_character(neighborhood_table$s_id)
    checkmate::assert_character(neighborhood_table$c_id)
    checkmate::assert_factor(neighborhood_table$sc_id)
    
    purrr::walk(
        neighborhood_table$sc_Source, 
        checkmate::assert_class,
        "napistu.source.Source",
        null.ok = TRUE
    )
    
    purrr::walk(
        neighborhood_table$vertices, 
        checkmate::assert_data_frame,
        null.ok = TRUE
    )

    purrr::walk(
        neighborhood_table$edges, 
        checkmate::assert_data_frame,
        null.ok = TRUE
    )
    
    purrr::walk(
        neighborhood_table$reaction_sources, 
        checkmate::assert_data_frame,
        null.ok = TRUE
    )
    
    return(invisible(TRUE))
}

#' Validate Neighborhood Network Type
#' 
#' @param network_type what type of neighborhood should be formed (ignored
#'   if \code{napistu_graph} is undirected).
#'   \describe{
#'     \item{downstream}{descendants of the focal node}
#'     \item{upstream}{ancestors of the focal node}
#'     \item{hourglass}{descendants and ancestors of focal node}
#'   }
#' 
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_neighborhoods_network_type <- function (network_type) {
    VALID_NETWORK_TYPES = c("downstream", "upstream", "hourglass")
    checkmate::assert_choice(network_type, VALID_NETWORK_TYPES)
    
    return(invisible(TRUE))
}

#' Validate Network Layout
#'
#' @param network_layout method to used for creating a network layout (e.g., `fr`, `kk`, `drl`)
#' 
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_network_layout <- function (network_layout = "fr") {
    
    VALID_LAYOUTS <- c("fr", "kk", "drl")
    checkmate::assert_choice(network_layout, VALID_LAYOUTS)
    
    return(invisible(TRUE))
}

#' Validate Score Palette
#' 
#' @param score_palette optional, color palette for scores. If provided this can be a string defining built-in palettes or a custom palette
#' \describe{
#'     \item{log2 fold-change}{A blue -> black -> yellow color palette which is symmetric around zero}
#'     \item{indication scores}{A gray -> yellow -> orange -> red palette ranging from 0-1}
#'     \item{otherwise}{A `Scale` object defining a custom palette}
#' }
#' @inheritParams validate_score_overlay_and_join_scores_on
#' 
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_score_palette <- function (score_palette, score_overlay) {
    
    if (is.null(score_overlay)) {
        if (!is.null(score_palette) && inherits(score_palette, "Scale")) {
            cli::cli_alert_warning("A custom score_palette was provided but there is no score_overlay so this palette will not be used")    
        }
        return(invisible(TRUE))   
    }
    
    if (inherits(score_palette, "character")) {
        
        SCORE_PALETTE_NAMES <- c("indication scores", "log2 fold-change")
        if (!(score_palette %in% SCORE_PALETTE_NAMES)) {
            cli::cli_abort("{.field {score_palette}} is not a valid value for {.arg score_palette}. Valid palettes are {.field {SCORE_PALETTE_NAMES}}")
        }
        
    } else if (inherits(score_palette, "Scale")) {
        # nothing to do
    } else {
        cli::cli_abort("{.field score_palette} is neither a keyword (inherits from character) nor a color palette (inherits from Scale)")
    }
    
    return(invisible(TRUE))
}

#' Validate Score Overlay and Join Scores On 
#' 
#' @param score_overlay optional, vertex-level scores containing `score`
#'   and the merging attribute specified in `join_on`
#' @param join_scores_on variable to use when merging vertices and score
#' 
#' @return Invisible TRUE if valid, throws error if invalid
#' 
#' @keywords internal
validate_score_overlay_and_join_scores_on <- function (score_overlay, join_scores_on) {
    checkmate::assert_data_frame(score_overlay, null.ok = TRUE)
    checkmate::assert_character(join_scores_on, min.len = 1)
    
    if (!is.null(score_overlay)) {
        checkmate::assertDataFrame(score_overlay)
        if (!(join_scores_on %in% colnames(score_overlay))) {
            cli::cli_abort(
                "{.field {join_scores_on}} is not present in {.arg score_overlay} but
                you are trying to join on {join_scores_on}"
            )
        }
        
        if (!("score" %in% colnames(score_overlay))) {
            cli::cli_abort(
                "{.field score} is missing from {.arg score_overlay}.
                It must be included if score_overlay is provided"
            )
        }
    }
}

#' Validate Show Edges If Specification
#' 
#' Validates the structure and content of a show_edges_if specification used
#' for filtering edges based on their attributes for visualization purposes.
#' 
#' @param show_edges_if A named list containing filters to apply based on edge 
#'   attributes. Each element should be a named list with:
#'   \itemize{
#'     \item \code{cutoff}: Numeric value specifying the threshold
#'     \item \code{retain}: Character string, either "above" or "below"
#'   }
#'   Example format:
#'   \code{list(
#'     weight = list(cutoff = 0.5, retain = "above"),
#'     correlation = list(cutoff = 0.9, retain = "below")
#'   )}
#' 
#' @return Invisible TRUE if validation passes, otherwise throws an error
#' 
#' @keywords internal
validate_show_edges_if <- function(show_edges_if = NULL) {
    
    if (is.null(show_edges_if)) {
        return (invisible(TRUE))
    }
    
    # Check if input is a list
    checkmate::assert_list(show_edges_if, 
                           min.len = 1,
                           .var.name = "show_edges_if")
    
    # Check if list is named
    checkmate::assert_names(names(show_edges_if),
                            type = "unique",
                            .var.name = "names(show_edges_if)")
    
    # Validate each filter specification
    for (attr_name in names(show_edges_if)) {
        filter_spec <- show_edges_if[[attr_name]]
        
        # Check if each element is a list
        checkmate::assert_list(filter_spec,
                               .var.name = sprintf("show_edges_if$%s", attr_name))
        
        # Check required elements
        required_elements <- c("cutoff", "retain")
        missing_elements <- setdiff(required_elements, names(filter_spec))
        if (length(missing_elements) > 0) {
            cli::cli_abort("Filter specification for {.field {attr_name}} is missing required elements: {.field {missing_elements}}")
        }
        
        # Validate cutoff
        checkmate::assert_number(filter_spec$cutoff,
                                 finite = TRUE,
                                 .var.name = sprintf("show_edges_if$%s$cutoff", attr_name))
        
        # Validate retain
        checkmate::assert_choice(filter_spec$retain,
                                 choices = c("above", "below"),
                                 .var.name = sprintf("show_edges_if$%s$retain", attr_name))
        
        # Check for unexpected elements
        unexpected_elements <- setdiff(names(filter_spec), required_elements)
        if (length(unexpected_elements) > 0) {
            cli::cli_warn("Filter specification for {.field {attr_name}} contains unexpected elements: {.field {unexpected_elements}}")
        }
    }
    
    invisible(TRUE)
}

ensure_required_keys <- function (keys, required_keys, object_name) {
    
    checkmate::assert_character(keys)
    checkmate::assert_character(required_keys)
    checkmate::assert_string(object_name)
    
    missing_keys <- setdiff(required_keys, keys)
    if (length(missing_keys) > 0) {
        cli::cli_abort("The {.arg {object_name}} list is malformed; it is missing the following key{?s}: {.field {missing_keys}}")
    }
    
}

validate_asset_list_thorough <- function (napistu_list) {
    
    sbml_dfs = napistu_list$sbml_dfs
    napistu_graph = napistu_list$napistu_graph
    species_identifiers = napistu_list$species_identifiers
    precomputed_distances = load_optional_list_value(napistu_list, "precomputed_distances")

    napistu_list$python_modules$napistu$network$ng_utils$validate_assets(
        sbml_dfs = sbml_dfs,
        napistu_graph = napistu_graph,
        precomputed_distances = precomputed_distances,
        identifiers_df = species_identifiers
    )
    
    return(invisible(TRUE))
}
